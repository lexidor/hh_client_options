Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.hh:2:1
    1 | <?hh // partial
[1] 2 | require_once(__DIR__.'/autoload.hack');
    3 | Facebook\AutoloadMap\initialize();

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.hh:3:1
    1 | <?hh // partial
    2 | require_once(__DIR__.'/autoload.hack');
[1] 3 | Facebook\AutoloadMap\initialize();

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.php:2:1
    1 | <?hh // partial
[1] 2 | require_once(__DIR__.'/autoload.hack');
    3 | Facebook\AutoloadMap\initialize();

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.php:3:1
    1 | <?hh // partial
    2 | require_once(__DIR__.'/autoload.hack');
[1] 3 | Facebook\AutoloadMap\initialize();

Typing[4138] The assigned type of this type constant is inconsistent with its parent [1]
-> This shape type allows unknown fields, and so it may contain fields other than those explicitly declared in its declaration. [2]
-> It is incompatible with a shape that does not allow unknown fields. [3]

vendor/hhvm/hhast/src/Linters/ConsistentLineEndingsLinter.hack:18:14
      16 |   extends AutoFixingLineLinter<LineLintError> {
      17 |   // Could become configurable later.
[1,3] 18 |   const type TConfig = shape('line ending' => LineEnding);
      19 | 
      20 |   private function getLineEnding(): LineEnding {

vendor/hhvm/hhast/src/Linters/BaseLinter.hack:19:38
      17 | abstract class BaseLinter {
      18 |   <<__Reifiable>>
[2]   19 |   const type TConfig as shape(...) = shape(...);
      20 | 
      21 |   abstract public function getLintErrorsAsync(): Awaitable<vec<LintError>>;

Typing[4053] No method readAsync in HH\Lib\IO\ReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\ReadHandle [3]
-> Declaration of HH\Lib\IO\ReadHandle is here [4]

vendor/hhvm/hhast/src/__Private/BufferedReader.hack:38:37
    14 | /** Temporary: this should be replaced by somethign in HSL IO */
    15 | final class BufferedReader {
[3] 16 |   public function __construct(private IO\ReadHandle $handle) {
    17 |   }
    18 | 
       :
    36 |     do {
    37 |       /* HHAST_IGNORE_ERROR[DontAwaitInALoop] */
[1] 38 |       $chunk = await $this->handle->readAsync();
    39 |       if ($chunk === '') {
    40 |         $this->buffer = $buf;

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    20 |  * `readFixedSizeAsync()` on top of `readAsync`.
    21 |  */
[4] 22 | interface ReadHandle extends Handle {
    23 |   /** An immediate, unordered read.
    24 |    *
       :
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

Typing[4053] No method readAsync in HH\Lib\IO\ReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\ReadHandle [3]
-> Declaration of HH\Lib\IO\ReadHandle is here [4]

vendor/hhvm/hhast/src/__Private/BufferedReader.hack:60:37
    14 | /** Temporary: this should be replaced by somethign in HSL IO */
    15 | final class BufferedReader {
[3] 16 |   public function __construct(private IO\ReadHandle $handle) {
    17 |   }
    18 | 
       :
    58 |     while (Str\length($buf) < $size) {
    59 |       /* HHAST_IGNORE_ERROR[DontAwaitInALoop] */
[1] 60 |       $chunk = await $this->handle->readAsync($size - Str\length($buf));
    61 |       if ($chunk === '') {
    62 |         $this->buffer = $buf;

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    20 |  * `readFixedSizeAsync()` on top of `readAsync`.
    21 |  */
[4] 22 | interface ReadHandle extends Handle {
    23 |   /** An immediate, unordered read.
    24 |    *
       :
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

Parsing[1002] XHP children declarations are no longer supported. [1]

vendor/hhvm/hhast/src/__Private/codegen/data/XHPChildren.SyntaxExample.hack:12:12
    10 | 
    11 | class :xhpchildren1 {
[1] 12 |   children (pcdata);
    13 | }
    14 | 

Naming[2049] Unbound name: Facebook\AutoloadMap\TestFixtures\MyExampleTest (an object type) [1]

vendor/hhvm/hhvm-autoload/testdata/fixtures/hh-only/test-dev.php:37:19
    35 |   );
    36 |   invariant(
[1] 37 |     \class_exists(MyExampleTest::class),
    38 |     "Should be able to load class from dev root in prod mode",
    39 |   );

Naming[2049] Unbound name: Facebook\AutoloadMap\TestFixtures\MyExampleTest (an object type) [1]

vendor/hhvm/hhvm-autoload/testdata/fixtures/hh-only/test-prod.php:39:20
    37 |   );
    38 |   invariant(
[1] 39 |     !\class_exists(MyExampleTest::class),
    40 |     "Should *not* be able to load class from dev root in prod mode",
    41 |   );

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/nuxed/console/example/app.hack:5:1
    3 | use namespace Nuxed\Console;
    4 | 
[1] 5 | require __DIR__.'/../vendor/hh_autoload.hh';
    6 | 
    7 | <<__EntryPoint>>

Parsing[1002] The goto operator is not allowed in Hack files [1]

vendor/nuxed/console/src/Nuxed/Console/Application.hack:312:11
    310 |         $exitCode = $event->getExitCode();
    311 |         if ($exitCode === Command\ExitCode::Success) {
[1] 312 |           goto terminate;
    313 |         }
    314 |       }

Parsing[1002] Labels are used only for goto, which is not allowed in Hack files [1]

vendor/nuxed/console/src/Nuxed/Console/Application.hack:320:5
    318 |     }
    319 | 
[1] 320 |     terminate:
    321 |     return await $this->terminate($input, $output, $command, 0);
    322 |   }

Naming[2049] Unbound name: Nuxed\Console\ErrorHandler\array [1]

vendor/nuxed/console/src/Nuxed/Console/ErrorHandle/ErrorHandler.hack:89:10
    87 |         /* HH_IGNORE_ERROR[4110] */
    88 |         $exception->getTrace(),
[1] 89 |         (array<string, mixed> $frame): dict<string, string> ==> {
    90 |           unset($frame['args']);
    91 |           /* HH_IGNORE_ERROR[4110] */

Typing[4110] Invalid argument [1]
-> Expected Nuxed\Console\ErrorHandler\array<string, mixed> [2]
-> But got darray<string, mixed> [3]
->   via this generic Tv1 [4]

vendor/nuxed/console/src/Nuxed/Console/ErrorHandle/ErrorHandler.hack:89:9
       84 | 
       85 |     $frames = Vec\filter<dict<string, string>>(
[3]    86 |       Vec\map<darray<string, mixed>, dict<string, string>>(
       87 |         /* HH_IGNORE_ERROR[4110] */
       88 |         $exception->getTrace(),
[1,2]  89 |         (array<string, mixed> $frame): dict<string, string> ==> {
[1]    90 |           unset($frame['args']);
[1]    91 |           /* HH_IGNORE_ERROR[4110] */
[1]    92 |           return dict<string, string>($frame);
[1]    93 |         },
       94 |       ),
       95 |       (dict<string, string> $frame): bool ==>

vendor/hhvm/hsl/src/vec/transform.php:105:13
      103 |   Traversable<Tv1> $traversable,
      104 |   <<__AtMostRxAsFunc>>
[4]   105 |   (function(Tv1): Tv2) $value_func,
      106 | ): vec<Tv2> {
      107 |   $result = vec[];

Typing[4005] This is not an object of type KeyedContainer, this is an object of type Nuxed\Console\ErrorHandler\array<string, mixed> [1]
-> Definition is here [2]

vendor/nuxed/console/src/Nuxed/Console/ErrorHandle/ErrorHandler.hack:90:17
    87 |         /* HH_IGNORE_ERROR[4110] */
    88 |         $exception->getTrace(),
[2] 89 |         (array<string, mixed> $frame): dict<string, string> ==> {
[1] 90 |           unset($frame['args']);
    91 |           /* HH_IGNORE_ERROR[4110] */
    92 |           return dict<string, string>($frame);

Typing[4341] The method getCode is not compatible with the overridden method [1]
-> This function is pure. [2]
-> This function is reactive. [1]

vendor/nuxed/console/src/Nuxed/Console/Exception/CommandNotFoundException.hack:13:19
     11 | 
     12 |   <<__Rx, __MaybeMutable>>
[1]  13 |   public function getCode(): int {
     14 |     return Command\ExitCode::CommandNotFound;
     15 |   }

/tmp/hh_server/hhi_3f918e8a/exceptions.hhi:101:19
     99 |   public final function setPrevious(Exception $previous): void;
    100 |   <<__Pure, __MaybeMutable>>
[2] 101 |   public function getCode(): int;
    102 |   <<__Pure, __MaybeMutable>>
    103 |   final public function getFile(): string;

Typing[4053] No method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/console/src/Nuxed/Console/Output/AbstractOutput.hack:83:20
    72 |    */
    73 |   protected async function writeTo(
[3] 74 |     IO\WriteHandle $handle,
    75 |     string $message,
    76 |     Verbosity $verbosity,
       :
    81 |     }
    82 | 
[1] 83 |     await $handle->writeAsync($this->format($message, $type));
    84 | 
    85 |     return;

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

Typing[4053] No method readAsync in HH\Lib\IO\ReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\ReadHandle [3]
-> Declaration of HH\Lib\IO\ReadHandle is here [4]

vendor/nuxed/console/src/Nuxed/Console/_Private/BufferedReader.hack:31:37
    15 |   private string $buffer = '';
    16 | 
[3] 17 |   public function __construct(private IO\ReadHandle $handle) {
    18 |   }
    19 | 
       :
    29 |     do {
    30 |       /* HHAST_IGNORE_ERROR[DontAwaitInALoop] */
[1] 31 |       $chunk = await $this->handle->readAsync();
    32 |       if ($chunk === '') {
    33 |         $this->buffer = $buf;

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    20 |  * `readFixedSizeAsync()` on top of `readAsync`.
    21 |  */
[4] 22 | interface ReadHandle extends Handle {
    23 |   /** An immediate, unordered read.
    24 |    *
       :
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

Typing[4053] No method readAsync in HH\Lib\IO\ReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\ReadHandle [3]
-> Declaration of HH\Lib\IO\ReadHandle is here [4]

vendor/nuxed/console/src/Nuxed/Console/_Private/BufferedReader.hack:53:37
    15 |   private string $buffer = '';
    16 | 
[3] 17 |   public function __construct(private IO\ReadHandle $handle) {
    18 |   }
    19 | 
       :
    51 |     while (Str\length($buf) < $size) {
    52 |       /* HHAST_IGNORE_ERROR[DontAwaitInALoop] */
[1] 53 |       $chunk = await $this->handle->readAsync($size - Str\length($buf));
    54 |       if ($chunk === '') {
    55 |         $this->buffer = $buf;

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    20 |  * `readFixedSizeAsync()` on top of `readAsync`.
    21 |  */
[4] 22 | interface ReadHandle extends Handle {
    23 |   /** An immediate, unordered read.
    24 |    *
       :
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

Typing[4128] The function HH\Lib\File\open_read_only_nd is deprecated: Use open_read_only() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:11:14
     9 | 
    10 |     try {
[1] 11 |       return File\open_read_only_nd($this->path->toString());
    12 |     } catch (\Exception $e) {
    13 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:46:10
    44 | 
    45 | <<__Deprecated("Use open_read_only() instead")>>
[2] 46 | function open_read_only_nd(string $path): CloseableReadHandle {
    47 |   return open_read_only($path);
    48 | }

Typing[4128] The function HH\Lib\File\open_write_only_nd is deprecated: Use open_write_only() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:55:14
    53 | 
    54 |     try {
[1] 55 |       return File\open_write_only_nd($this->path->toString(), $mode);
    56 |     } catch (\Exception $e) {
    57 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:51:10
    49 | 
    50 | <<__Deprecated("Use open_write_only() instead")>>
[2] 51 | function open_write_only_nd(
    52 |   string $path,
    53 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,

Typing[4128] The function HH\Lib\File\open_read_write_nd is deprecated: Use open_read_write() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:104:14
    102 | 
    103 |     try {
[1] 104 |       return File\open_read_write_nd($this->path()->toString(), $mode);
    105 |     } catch (\Exception $e) {
    106 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:60:10
     58 | 
     59 | <<__ReturnDisposable, __Deprecated("Use open_read_write() instead")>>
[2]  60 | function open_read_write_nd(
     61 |   string $path,
     62 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,

Typing[4187] Disposable objects may only be created in a using statement or return from function marked <<__ReturnDisposable>> [1]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:104:14
    102 | 
    103 |     try {
[1] 104 |       return File\open_read_write_nd($this->path()->toString(), $mode);
    105 |     } catch (\Exception $e) {
    106 |       throw new Exception\RuntimeException(

Typing[4053] No method writeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:310:26
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    308 |       try {
    309 |         using ($_lock = $handle->tryLockx(File\LockType::EXCLUSIVE)) {
[1] 310 |           await $handle->writeAsync($data);
    311 |         }
    312 |       } catch (File\AlreadyLockedException $e) {

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
     57 |    * do not want this to happen.
     58 |    */
[2]  59 |   public function writeAllAsync(
     60 |     string $bytes,
     61 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No method writeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:314:26
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    312 |       } catch (File\AlreadyLockedException $e) {
    313 |         using ($_lock = $handle->lock(File\LockType::EXCLUSIVE)) {
[1] 314 |           await $handle->writeAsync($data);
    315 |         }
    316 |       } finally {

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
     57 |    * do not want this to happen.
     58 |    */
[2]  59 |   public function writeAllAsync(
     60 |     string $bytes,
     61 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No method closeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean close instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:317:24
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    315 |         }
    316 |       } finally {
[1] 317 |         await $handle->closeAsync();
    318 |       }
    319 |     } catch (\Exception $e) {

vendor/hhvm/hsl-experimental/src/io/CloseableHandle.php:21:19
     19 | interface CloseableHandle extends Handle {
     20 |   /** Close the handle */
[2]  21 |   public function close(): void;
     22 | 
     23 |   /** Close the handle when the returned disposable is disposed.

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No method readAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:339:33
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    337 |       try {
    338 |         using ($_lock = $handle->tryLockx(File\LockType::SHARED)) {
[1] 339 |           return await $handle->readAsync($length);
    340 |         }
    341 |       } catch (File\AlreadyLockedException $e) {

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
     68 |    * unnecessarily hitting the request memory limit.
     69 |    */
[2]  70 |   public function readAllAsync(
     71 |     ?int $max_bytes = null,
     72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No method readAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:343:33
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    341 |       } catch (File\AlreadyLockedException $e) {
    342 |         using ($_lock = $handle->lock(File\LockType::SHARED)) {
[1] 343 |           return await $handle->readAsync($length);
    344 |         }
    345 |       } finally {

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
     68 |    * unnecessarily hitting the request memory limit.
     69 |    */
[2]  70 |   public function readAllAsync(
     71 |     ?int $max_bytes = null,
     72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No method closeAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean close instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:346:24
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    344 |         }
    345 |       } finally {
[1] 346 |         await $handle->closeAsync();
    347 |       }
    348 |     } catch (\Exception $e) {

vendor/hhvm/hsl-experimental/src/io/CloseableHandle.php:21:19
     19 | interface CloseableHandle extends Handle {
     20 |   /** Close the handle */
[2]  21 |   public function close(): void;
     22 | 
     23 |   /** Close the handle when the returned disposable is disposed.

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No method seekAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean seek instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:16:20
     7 |  */
     8 | async function copy(
[3]  9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
       :
    14 | ): Awaitable<bool> {
    15 |   if ($iteration === 0) {
[1] 16 |     await $source->seekAsync(0);
    17 |   }
    18 | 

vendor/hhvm/hsl-experimental/src/io/SeekableHandle.php:21:19
    19 |    * handle is always offset 0.
    20 |    */
[2] 21 |   public function seek(int $offset): void;
    22 | 
    23 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No method readAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:20:29
     7 |  */
     8 | async function copy(
[3]  9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
       :
    18 | 
    19 |   $iteration++;
[1] 20 |   $content = await $source->readAsync($max_bytes, $timeout_ns);
    21 |   if ('' !== $content) {
    22 |     await $target->writeAsync($content, $timeout_ns);

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:22:20
     8 | async function copy(
     9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
[3] 10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
    12 |   ?int $timeout_ns = null,
       :
    20 |   $content = await $source->readAsync($max_bytes, $timeout_ns);
    21 |   if ('' !== $content) {
[1] 22 |     await $target->writeAsync($content, $timeout_ns);
    23 |     await copy($source, $target, $max_bytes, $timeout_ns, $iteration);
    24 |   }

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

Typing[4053] No method readAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:37:32
    28 | 
    29 | async function copy_range(
[3] 30 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    31 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    32 |   int $length,
       :
    35 | ): Awaitable<int> {
    36 |   if ($remaining >= $length) {
[1] 37 |     $contents = await $source->readAsync($length, $timeout_ns);
    38 |     if ('' !== $contents) {
    39 |       $remaining -= Str\length($contents);

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:40:22
    29 | async function copy_range(
    30 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
[3] 31 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    32 |   int $length,
    33 |   int $remaining,
       :
    38 |     if ('' !== $contents) {
    39 |       $remaining -= Str\length($contents);
[1] 40 |       await $target->writeAsync($contents);
    41 |       await copy_range($source, $target, $length, $remaining, $timeout_ns);
    42 |     }

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

Typing[4053] No method seekAsync in HH\Lib\IO\SeekableReadWriteHandle [1]
-> Did you mean seek instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadWriteHandle [3]
->   via this generic T [4]
-> Declaration of HH\Lib\IO\SeekableReadWriteHandle is here [5]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:20:18
     18 | 
     19 |   $remaining = $range['last'] - $range['first'] + 1;
[1]  20 |   await $source->seekAsync($range['first']);
     21 |   $remaining = await copy_range($source, $target, $maxBufferLength, $remaining);
     22 |   if ($remaining > 0) {

vendor/hhvm/hsl-experimental/src/io/SeekableHandle.php:21:19
     19 |    * handle is always offset 0.
     20 |    */
[2]  21 |   public function seek(int $offset): void;
     22 | 
     23 |   /**

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IResponse.hack:21:38
     19 |  * message and return an instance that contains the changed state.
     20 |  */
[3]  21 | interface IResponse extends IMessage<IO\SeekableReadWriteHandle> {
     22 |   /**
     23 |    * Gets the response status code.

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IMessage.hack:142:30
    140 |    * Gets the body of the message.
    141 |    */
[4] 142 |   public function getBody(): T;
    143 | 
    144 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:83:13
     81 |   interface CloseableReadWriteHandle
     82 |     extends ReadWriteHandle, CloseableWriteHandle, CloseableReadHandle {}
[5]  83 |   interface SeekableReadWriteHandle
     84 |     extends ReadWriteHandle, SeekableWriteHandle, SeekableReadHandle {}
     85 |   interface CloseableSeekableReadWriteHandle

Typing[4053] No method readAsync in HH\Lib\IO\SeekableReadWriteHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadWriteHandle [3]
->   via this generic T [4]
-> Declaration of HH\Lib\IO\SeekableReadWriteHandle is here [5]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:23:32
     21 |   $remaining = await copy_range($source, $target, $maxBufferLength, $remaining);
     22 |   if ($remaining > 0) {
[1]  23 |     $contents = await $source->readAsync($remaining);
     24 |     if ('' !== $contents) {
     25 |       await $target->writeAsync($contents);

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
     68 |    * unnecessarily hitting the request memory limit.
     69 |    */
[2]  70 |   public function readAllAsync(
     71 |     ?int $max_bytes = null,
     72 |     ?int $timeout_ns = null,

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IResponse.hack:21:38
     19 |  * message and return an instance that contains the changed state.
     20 |  */
[3]  21 | interface IResponse extends IMessage<IO\SeekableReadWriteHandle> {
     22 |   /**
     23 |    * Gets the response status code.

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IMessage.hack:142:30
    140 |    * Gets the body of the message.
    141 |    */
[4] 142 |   public function getBody(): T;
    143 | 
    144 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:83:13
     81 |   interface CloseableReadWriteHandle
     82 |     extends ReadWriteHandle, CloseableWriteHandle, CloseableReadHandle {}
[5]  83 |   interface SeekableReadWriteHandle
     84 |     extends ReadWriteHandle, SeekableWriteHandle, SeekableReadHandle {}
     85 |   interface CloseableSeekableReadWriteHandle

Typing[4053] No method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:25:22
     6 | async function stream(
     7 |   Message\IResponse $response,
[3]  8 |   IO\WriteHandle $target,
     9 |   int $maxBufferLength,
    10 | ): Awaitable<bool> {
       :
    23 |     $contents = await $source->readAsync($remaining);
    24 |     if ('' !== $contents) {
[1] 25 |       await $target->writeAsync($contents);
    26 |     }
    27 |   }

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

Typing[4053] No method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/usox/hackttp/example/index.hack:12:31
     10 |   $response = $response->withAddedHeaderLine('X-ZOMG', 'aggi');
     11 | 
[1]  12 |   await $response->getBody()->writeAsync('foo');
     13 | 
     14 |   $emitter = new \Usox\HackTTP\Response\TemporaryFileSapiEmitter();

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
     19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
     20 |  */
[4]  21 | interface WriteHandle extends Handle {
     22 |   /** An immediate unordered write.
     23 |    *
        :
     57 |    * do not want this to happen.
     58 |    */
[2]  59 |   public function writeAllAsync(
     60 |     string $bytes,
     61 |     ?int $timeout_ns = null,

vendor/facebook/hack-http-request-response-interfaces/src/ResponseInterface.hack:100:30
     98 |    * Gets the body of the message.
     99 |    */
[3] 100 |   public function getBody(): IO\WriteHandle;
    101 | 
    102 |   /**

Typing[4053] No method readAsync in HH\Lib\IO\ReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\ReadHandle [3]
-> Declaration of HH\Lib\IO\ReadHandle is here [4]

vendor/usox/hackttp/src/UploadedFile.hack:60:37
    20 | 
    21 |   public function __construct(
[3] 22 |     private IO\ReadHandle $stream,
    23 |     private ?int $size,
    24 |     private ?Message\UploadedFileError $upload_status = null,
       :
    58 |     do {
    59 |       /* HHAST_IGNORE_ERROR[DontAwaitInALoop] */
[1] 60 |       $chunk = await $this->stream->readAsync();
    61 |       if ($chunk === '') {
    62 |         break;

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    20 |  * `readFixedSizeAsync()` on top of `readAsync`.
    21 |  */
[4] 22 | interface ReadHandle extends Handle {
    23 |   /** An immediate, unordered read.
    24 |    *
       :
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

Typing[4053] No method writeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/usox/hackttp/src/UploadedFile.hack:65:22
    63 |       }
    64 |       /* HHAST_IGNORE_ERROR[DontAwaitInALoop] */
[1] 65 |       await $target->writeAsync($chunk);
    66 |     } while (true);
    67 | 

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/open.php:23:4
    21 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,
    22 |   int $create_file_permissions = 0644,
[3] 23 | ): CloseableWriteHandle {
    24 |   return OS\open(
    25 |     $path,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
    20 | }
    21 | 
[4] 22 | interface CloseableWriteHandle
    23 |   extends
    24 |     IO\CloseableSeekableWriteHandle,

41 errors found.
