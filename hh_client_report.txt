Typing[4138] The assigned type of this type constant is inconsistent with its parent [1]
-> This shape type allows unknown fields, and so it may contain fields other than those explicitly declared in its declaration. [2]
-> It is incompatible with a shape that does not allow unknown fields. [3]

vendor/hhvm/hhast/src/Linters/ConsistentLineEndingsLinter.hack:18:14
      16 |   extends AutoFixingLineLinter<LineLintError> {
      17 |   // Could become configurable later.
[1,3] 18 |   const type TConfig = shape('line ending' => LineEnding);
      19 | 
      20 |   private function getLineEnding(): LineEnding {

vendor/hhvm/hhast/src/Linters/BaseLinter.hack:19:38
      17 | abstract class BaseLinter {
      18 |   <<__Reifiable>>
[2]   19 |   const type TConfig as shape(...) = shape(...);
      20 | 
      21 |   abstract public function getLintErrorsAsync(): Awaitable<vec<LintError>>;

Parsing[1002] XHP children declarations are no longer supported. [1]

vendor/hhvm/hhast/src/__Private/codegen/data/XHPChildren.SyntaxExample.hack:12:12
    10 | 
    11 | class :xhpchildren1 {
[1] 12 |   children (pcdata);
    13 | }
    14 | 

Naming[2049] Unbound name: Facebook\AutoloadMap\TestFixtures\MyExampleTest (an object type) [1]

vendor/hhvm/hhvm-autoload/testdata/fixtures/hh-only/test-dev.php:37:19
    35 |   );
    36 |   invariant(
[1] 37 |     \class_exists(MyExampleTest::class),
    38 |     "Should be able to load class from dev root in prod mode",
    39 |   );

Naming[2049] Unbound name: Facebook\AutoloadMap\TestFixtures\MyExampleTest (an object type) [1]

vendor/hhvm/hhvm-autoload/testdata/fixtures/hh-only/test-prod.php:39:20
    37 |   );
    38 |   invariant(
[1] 39 |     !\class_exists(MyExampleTest::class),
    40 |     "Should *not* be able to load class from dev root in prod mode",
    41 |   );

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/c/select.php:201:5
    199 |     /* HH_FIXME[4200] intersection of Iterable and Rx\Traversable is reactive */
    200 |     /* HH_FIXME[4387] reported here as of 2020.09.21, hack v4.51.0 */
[1] 201 |     /* HH_FIXME[4390] need ctx constants */
    202 |     return $traversable->lastValue();
    203 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/c/select.php:202:12
    192 | function last<T>(
    193 |   Traversable<T> $traversable,
[2] 194 | )[]: ?T {
    195 |   if ($traversable is Container<_>) {
    196 |     return _Private\Native\last($traversable);
        :
    200 |     /* HH_FIXME[4387] reported here as of 2020.09.21, hack v4.51.0 */
    201 |     /* HH_FIXME[4390] need ctx constants */
[1] 202 |     return $traversable->lastValue();
    203 |   }
    204 |   $value = null;

/tmp/hh_server/hhi_3b2be946/interfaces.hhi:508:19
    506 |    *           current `Iterable` is empty.
    507 |    */
[3] 508 |   public function lastValue(): ?Tv;
    509 | }
    510 | 

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/c/select.php:264:5
    262 |     /* HH_FIXME[4200] intersection of Iterable and Rx\Traversable is reactive */
    263 |     /* HH_FIXME[4387] reported here as of 2020.09.21, hack v4.51.0 */
[1] 264 |     /* HH_FIXME[4390] need ctx constants */
    265 |     return $traversable->lastKey();
    266 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/c/select.php:265:12
    255 | function last_key<Tk, Tv>(
    256 |   KeyedTraversable<Tk, Tv> $traversable,
[2] 257 | )[]: ?Tk {
    258 |   if ($traversable is KeyedContainer<_, _>) {
    259 |     return _Private\Native\last_key($traversable);
        :
    263 |     /* HH_FIXME[4387] reported here as of 2020.09.21, hack v4.51.0 */
    264 |     /* HH_FIXME[4390] need ctx constants */
[1] 265 |     return $traversable->lastKey();
    266 |   }
    267 |   $key = null;

/tmp/hh_server/hhi_3b2be946/interfaces.hhi:787:19
    785 |    *           current `KeyedIterable` is empty.
    786 |    */
[3] 787 |   public function lastKey(): ?Tk;
    788 | }
    789 | 

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:30:3
    28 | 
    29 |   /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 30 |   /* HH_FIXME[4390] Magic Function */
    31 |   await AwaitAllWaitHandle::fromDict($dict);
    32 |   foreach ($dict as $key => $value) {

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:31:9
     24 | async function from_async<Tk as arraykey, Tv>(
     25 |   KeyedTraversable<Tk, Awaitable<Tv>> $awaitables,
[2]  26 | )[]: Awaitable<dict<Tk, Tv>> {
     27 |   $dict = cast_clear_legacy_array_mark($awaitables);
     28 | 
     29 |   /* HH_FIXME[4387] Hide the magic from reactivity */
     30 |   /* HH_FIXME[4390] Magic Function */
[1]  31 |   await AwaitAllWaitHandle::fromDict($dict);
     32 |   foreach ($dict as $key => $value) {
     33 |     /* HH_FIXME[4387] Hide the magic from reactivity */

/tmp/hh_server/hhi_3b2be946/classes.hhi:159:26
    157 |     darray<arraykey, Awaitable<mixed>> $deps
    158 |   ): Awaitable<void>;
[3] 159 |   public static function fromDict(
    160 |     dict<arraykey, Awaitable<mixed>> $deps
    161 |   ): Awaitable<void>;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:34:5
    32 |   foreach ($dict as $key => $value) {
    33 |     /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 34 |     /* HH_FIXME[4390] Magic Function */
    35 |     $dict[$key] = \HH\Asio\result($value);
    36 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:35:19
    24 | async function from_async<Tk as arraykey, Tv>(
    25 |   KeyedTraversable<Tk, Awaitable<Tv>> $awaitables,
[2] 26 | )[]: Awaitable<dict<Tk, Tv>> {
    27 |   $dict = cast_clear_legacy_array_mark($awaitables);
    28 | 
       :
    33 |     /* HH_FIXME[4387] Hide the magic from reactivity */
    34 |     /* HH_FIXME[4390] Magic Function */
[1] 35 |     $dict[$key] = \HH\Asio\result($value);
    36 |   }
    37 |   /* HH_FIXME[4110] Reuse the existing dict to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_asio.hhi:17:12
    15 | namespace HH\Asio {
    16 |   function join<T>(Awaitable<T> $awaitable): T;
[3] 17 |   function result<T>(Awaitable<T> $awaitable): T;
    18 |   function name(Awaitable<mixed> $awaitable): string;
    19 |   function has_finished(Awaitable<mixed> $awaitable): bool;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[4] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:62:3
    60 | 
    61 |   /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 62 |   /* HH_FIXME[4390] Magic Function */
    63 |   await AwaitAllWaitHandle::fromDict($awaitables);
    64 |   foreach ($awaitables as $key => $value) {

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $async_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:63:9
     51 |   Traversable<Tk> $keys,
     52 |   (function(Tk)[_]: Awaitable<Tv>) $async_func,
[2]  53 | )[ctx $async_func]: Awaitable<dict<Tk, Tv>> {
     54 |   $awaitables = dict[];
     55 |   foreach ($keys as $key) {
        :
     61 |   /* HH_FIXME[4387] Hide the magic from reactivity */
     62 |   /* HH_FIXME[4390] Magic Function */
[1]  63 |   await AwaitAllWaitHandle::fromDict($awaitables);
     64 |   foreach ($awaitables as $key => $value) {
     65 |     /* HH_FIXME[4387] Hide the magic from reactivity */

/tmp/hh_server/hhi_3b2be946/classes.hhi:159:26
    157 |     darray<arraykey, Awaitable<mixed>> $deps
    158 |   ): Awaitable<void>;
[3] 159 |   public static function fromDict(
    160 |     dict<arraykey, Awaitable<mixed>> $deps
    161 |   ): Awaitable<void>;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:66:5
    64 |   foreach ($awaitables as $key => $value) {
    65 |     /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 66 |     /* HH_FIXME[4390] Magic Function */
    67 |     $awaitables[$key] = \HH\Asio\result($value);
    68 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $async_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:67:25
    51 |   Traversable<Tk> $keys,
    52 |   (function(Tk)[_]: Awaitable<Tv>) $async_func,
[2] 53 | )[ctx $async_func]: Awaitable<dict<Tk, Tv>> {
    54 |   $awaitables = dict[];
    55 |   foreach ($keys as $key) {
       :
    65 |     /* HH_FIXME[4387] Hide the magic from reactivity */
    66 |     /* HH_FIXME[4390] Magic Function */
[1] 67 |     $awaitables[$key] = \HH\Asio\result($value);
    68 |   }
    69 |   /* HH_FIXME[4110] Reuse the existing dict to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_asio.hhi:17:12
    15 | namespace HH\Asio {
    16 |   function join<T>(Awaitable<T> $awaitable): T;
[3] 17 |   function result<T>(Awaitable<T> $awaitable): T;
    18 |   function name(Awaitable<mixed> $awaitable): string;
    19 |   function has_finished(Awaitable<mixed> $awaitable): bool;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[4] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4401] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4401 [1]

vendor/hhvm/hsl/src/dict/async.php:141:5
    139 |   $dict = cast_clear_legacy_array_mark($traversable);
    140 |   foreach ($dict as $key => $value) {
[1] 141 |     /* HH_FIXME[4401] need to make this safe to coeffects */
    142 |     $dict[$key] = $value_func($value);
    143 |   }

Typing[4401] Not immediately awaiting Awaitable-typed values requires the capability AccessStaticVariable, which is not provided by the context. [1]
-> The local (enclosing) context provides the capability ctx $value_func [2]
-> Hack provides a list of supported contexts here [3]

vendor/hhvm/hsl/src/dict/async.php:142:19
    136 |   KeyedTraversable<Tk, Tv1> $traversable,
    137 |   (function(Tv1)[_]: Awaitable<Tv2>) $value_func,
[2] 138 | )[ctx $value_func]: Awaitable<dict<Tk, Tv2>> {
    139 |   $dict = cast_clear_legacy_array_mark($traversable);
    140 |   foreach ($dict as $key => $value) {
    141 |     /* HH_FIXME[4401] need to make this safe to coeffects */
[1] 142 |     $dict[$key] = $value_func($value);
    143 |   }
    144 | 

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[3]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:147:3
    145 |   /* HH_FIXME[4110] Okay to pass in Awaitable */
    146 |   /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 147 |   /* HH_FIXME[4390] Magic Function */
    148 |   await AwaitAllWaitHandle::fromDict($dict);
    149 |   foreach ($dict as $key => $value) {

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $value_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:148:9
    136 |   KeyedTraversable<Tk, Tv1> $traversable,
    137 |   (function(Tv1)[_]: Awaitable<Tv2>) $value_func,
[2] 138 | )[ctx $value_func]: Awaitable<dict<Tk, Tv2>> {
    139 |   $dict = cast_clear_legacy_array_mark($traversable);
    140 |   foreach ($dict as $key => $value) {
        :
    146 |   /* HH_FIXME[4387] Hide the magic from reactivity */
    147 |   /* HH_FIXME[4390] Magic Function */
[1] 148 |   await AwaitAllWaitHandle::fromDict($dict);
    149 |   foreach ($dict as $key => $value) {
    150 |     /* HH_FIXME[4110] Reuse the existing dict to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/classes.hhi:159:26
    157 |     darray<arraykey, Awaitable<mixed>> $deps
    158 |   ): Awaitable<void>;
[3] 159 |   public static function fromDict(
    160 |     dict<arraykey, Awaitable<mixed>> $deps
    161 |   ): Awaitable<void>;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:152:5
    150 |     /* HH_FIXME[4110] Reuse the existing dict to reduce peak memory. */
    151 |     /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 152 |     /* HH_FIXME[4390] Magic Function */
    153 |     $dict[$key] = \HH\Asio\result($value);
    154 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $value_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:153:19
    136 |   KeyedTraversable<Tk, Tv1> $traversable,
    137 |   (function(Tv1)[_]: Awaitable<Tv2>) $value_func,
[2] 138 | )[ctx $value_func]: Awaitable<dict<Tk, Tv2>> {
    139 |   $dict = cast_clear_legacy_array_mark($traversable);
    140 |   foreach ($dict as $key => $value) {
        :
    151 |     /* HH_FIXME[4387] Hide the magic from reactivity */
    152 |     /* HH_FIXME[4390] Magic Function */
[1] 153 |     $dict[$key] = \HH\Asio\result($value);
    154 |   }
    155 |   /* HH_FIXME[4110] Reuse the existing dict to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_asio.hhi:17:12
     15 | namespace HH\Asio {
     16 |   function join<T>(Awaitable<T> $awaitable): T;
[3]  17 |   function result<T>(Awaitable<T> $awaitable): T;
     18 |   function name(Awaitable<mixed> $awaitable): string;
     19 |   function has_finished(Awaitable<mixed> $awaitable): bool;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:177:3
    175 | 
    176 |   /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 177 |   /* HH_FIXME[4390] Magic Function */
    178 |   await AwaitAllWaitHandle::fromDict($awaitables);
    179 |   foreach ($awaitables as $index => $value) {

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $async_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:178:9
    169 |   KeyedTraversable<Tk, Tv1> $traversable,
    170 |   (function(Tk, Tv1)[_]: Awaitable<Tv2>) $async_func,
[2] 171 | )[ctx $async_func]: Awaitable<dict<Tk, Tv2>> {
    172 |   $awaitables = map_with_key($traversable, $async_func);
    173 |   /* HH_FIXME[4135] Unset local variable to reduce peak memory. */
        :
    176 |   /* HH_FIXME[4387] Hide the magic from reactivity */
    177 |   /* HH_FIXME[4390] Magic Function */
[1] 178 |   await AwaitAllWaitHandle::fromDict($awaitables);
    179 |   foreach ($awaitables as $index => $value) {
    180 |     /* HH_FIXME[4387] Hide the magic from reactivity */

/tmp/hh_server/hhi_3b2be946/classes.hhi:159:26
    157 |     darray<arraykey, Awaitable<mixed>> $deps
    158 |   ): Awaitable<void>;
[3] 159 |   public static function fromDict(
    160 |     dict<arraykey, Awaitable<mixed>> $deps
    161 |   ): Awaitable<void>;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/dict/async.php:181:5
    179 |   foreach ($awaitables as $index => $value) {
    180 |     /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 181 |     /* HH_FIXME[4390] Magic Function */
    182 |     $awaitables[$index] = \HH\Asio\result($value);
    183 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $async_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/dict/async.php:182:27
    169 |   KeyedTraversable<Tk, Tv1> $traversable,
    170 |   (function(Tk, Tv1)[_]: Awaitable<Tv2>) $async_func,
[2] 171 | )[ctx $async_func]: Awaitable<dict<Tk, Tv2>> {
    172 |   $awaitables = map_with_key($traversable, $async_func);
    173 |   /* HH_FIXME[4135] Unset local variable to reduce peak memory. */
        :
    180 |     /* HH_FIXME[4387] Hide the magic from reactivity */
    181 |     /* HH_FIXME[4390] Magic Function */
[1] 182 |     $awaitables[$index] = \HH\Asio\result($value);
    183 |   }
    184 |   /* HH_FIXME[4110] Reuse the existing dict to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_asio.hhi:17:12
     15 | namespace HH\Asio {
     16 |   function join<T>(Awaitable<T> $awaitable): T;
[3]  17 |   function result<T>(Awaitable<T> $awaitable): T;
     18 |   function name(Awaitable<mixed> $awaitable): string;
     19 |   function has_finished(Awaitable<mixed> $awaitable): bool;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/str/transform.php:29:3
    27 |   /* HH_FIXME[2049] calling stdlib directly */
    28 |   /* HH_FIXME[4107] calling stdlib directly */
[1] 29 |   /* HH_FIXME[4390] \ucfirst is missing [] */
    30 |   return \ucfirst($string);
    31 | }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/str/transform.php:30:10
    24 | function capitalize(
    25 |   string $string,
[2] 26 | )[]: string {
    27 |   /* HH_FIXME[2049] calling stdlib directly */
    28 |   /* HH_FIXME[4107] calling stdlib directly */
    29 |   /* HH_FIXME[4390] \ucfirst is missing [] */
[1] 30 |   return \ucfirst($string);
    31 | }
    32 | 

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_string.hhi:59:10
    57 | function strtoupper(string $str)[];
    58 | <<__PHPStdLib>>
[3] 59 | function ucfirst(string $str);
    60 | <<__PHPStdLib>>
    61 | function lcfirst(string $str);

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[4] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/str/transform.php:48:3
    46 |   /* HH_FIXME[2049] calling stdlib directly */
    47 |   /* HH_FIXME[4107] calling stdlib directly */
[1] 48 |   /* HH_FIXME[4390] \ucwords is missing [] */
    49 |   return \ucwords($string, $delimiters);
    50 | }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/str/transform.php:49:10
    43 |   string $string,
    44 |   string $delimiters = " \t\r\n\f\v",
[2] 45 | )[]: string {
    46 |   /* HH_FIXME[2049] calling stdlib directly */
    47 |   /* HH_FIXME[4107] calling stdlib directly */
    48 |   /* HH_FIXME[4390] \ucwords is missing [] */
[1] 49 |   return \ucwords($string, $delimiters);
    50 | }
    51 | 

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_string.hhi:63:10
    61 | function lcfirst(string $str);
    62 | <<__PHPStdLib>>
[3] 63 | function ucwords(string $str, string $delimiters = " \t\r\n\f\v");
    64 | <<__PHPStdLib, __Pure>>
    65 | function trim(string $str, string $charlist = HPHP_TRIM_CHARLIST)[]/*: string*/;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[4] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/str/transform.php:179:3
    177 |   string $replacement,
    178 | )[rx]: string {
[1] 179 |   /* HH_FIXME[4390] Rx calling non-rx */
    180 |   /* HH_FIXME[2049] calling stdlib directly */
    181 |   /* HH_FIXME[4107] calling stdlib directly */

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {Rx, WriteProperty} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/str/transform.php:182:10
    176 |   string $needle,
    177 |   string $replacement,
[2] 178 | )[rx]: string {
    179 |   /* HH_FIXME[4390] Rx calling non-rx */
    180 |   /* HH_FIXME[2049] calling stdlib directly */
    181 |   /* HH_FIXME[4107] calling stdlib directly */
[1] 182 |   return \str_ireplace($needle, $replacement, $haystack);
    183 | }
    184 | 

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_string.hhi:99:10
     97 | function str_replace_with_count($search, $replace, $subject, inout $count);
     98 | <<__PHPStdLib>> // not pure: uses global locale for capitalization
[3]  99 | function str_ireplace($search, $replace, $subject);
    100 | <<__PHPStdLib>>
    101 | function str_ireplace_with_count($search, $replace, $subject, inout $count);

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/str/transform.php:243:3
    241 |   /* HH_FIXME[2049] calling stdlib directly */
    242 |   /* HH_FIXME[4107] calling stdlib directly */
[1] 243 |   /* HH_FIXME[4390] Rx calling non-rx */
    244 |   return \str_ireplace(
    245 |     /* HH_FIXME[2049] calling stdlib directly */

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {Rx, WriteProperty} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/str/transform.php:244:10
    238 |   string $haystack,
    239 |   KeyedContainer<string, string> $replacements,
[2] 240 | )[rx]: string {
    241 |   /* HH_FIXME[2049] calling stdlib directly */
    242 |   /* HH_FIXME[4107] calling stdlib directly */
    243 |   /* HH_FIXME[4390] Rx calling non-rx */
[1] 244 |   return \str_ireplace(
[1] 245 |     /* HH_FIXME[2049] calling stdlib directly */
[1] 246 |     /* HH_FIXME[4107] calling stdlib directly */
[1] 247 |     \array_keys($replacements),
[1] 248 |     /* HH_FIXME[2049] calling stdlib directly */
[1] 249 |     /* HH_FIXME[4107] calling stdlib directly */
[1] 250 |     \array_values($replacements),
[1] 251 |     $haystack,
[1] 252 |   );
    253 | }
    254 | 

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_string.hhi:99:10
     97 | function str_replace_with_count($search, $replace, $subject, inout $count);
     98 | <<__PHPStdLib>> // not pure: uses global locale for capitalization
[3]  99 | function str_ireplace($search, $replace, $subject);
    100 | <<__PHPStdLib>>
    101 | function str_ireplace_with_count($search, $replace, $subject, inout $count);

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/vec/async.php:28:3
    26 | 
    27 |   /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 28 |   /* HH_FIXME[4390] Magic Function */
    29 |   await AwaitAllWaitHandle::fromVec($vec);
    30 |   foreach ($vec as $index => $value) {

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/vec/async.php:29:9
     22 | async function from_async<Tv>(
     23 |   Traversable<Awaitable<Tv>> $awaitables,
[2]  24 | )[]: Awaitable<vec<Tv>> {
     25 |   $vec = cast_clear_legacy_array_mark($awaitables);
     26 | 
     27 |   /* HH_FIXME[4387] Hide the magic from reactivity */
     28 |   /* HH_FIXME[4390] Magic Function */
[1]  29 |   await AwaitAllWaitHandle::fromVec($vec);
     30 |   foreach ($vec as $index => $value) {
     31 |     /* HH_FIXME[4387] Hide the magic from reactivity */

/tmp/hh_server/hhi_3b2be946/classes.hhi:165:26
    163 |     \ConstMap<arraykey, Awaitable<mixed>> $deps
    164 |   ): Awaitable<void>;
[3] 165 |   public static function fromVec(
    166 |     vec<Awaitable<mixed>> $deps
    167 |   ): Awaitable<void>;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/vec/async.php:32:5
    30 |   foreach ($vec as $index => $value) {
    31 |     /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 32 |     /* HH_FIXME[4390] Magic Function */
    33 |     $vec[$index] = \HH\Asio\result($value);
    34 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability set {} [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/vec/async.php:33:20
    22 | async function from_async<Tv>(
    23 |   Traversable<Awaitable<Tv>> $awaitables,
[2] 24 | )[]: Awaitable<vec<Tv>> {
    25 |   $vec = cast_clear_legacy_array_mark($awaitables);
    26 | 
       :
    31 |     /* HH_FIXME[4387] Hide the magic from reactivity */
    32 |     /* HH_FIXME[4390] Magic Function */
[1] 33 |     $vec[$index] = \HH\Asio\result($value);
    34 |   }
    35 |   /* HH_FIXME[4110] Reuse the existing vec to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_asio.hhi:17:12
    15 | namespace HH\Asio {
    16 |   function join<T>(Awaitable<T> $awaitable): T;
[3] 17 |   function result<T>(Awaitable<T> $awaitable): T;
    18 |   function name(Awaitable<mixed> $awaitable): string;
    19 |   function has_finished(Awaitable<mixed> $awaitable): bool;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[4] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4401] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4401 [1]

vendor/hhvm/hsl/src/vec/async.php:87:5
    85 |   $vec = cast_clear_legacy_array_mark($traversable);
    86 |   foreach ($vec as $i => $value) {
[1] 87 |     /* HH_FIXME[4401] need to make this safe to coeffects */
    88 |     $vec[$i] = $async_func($value);
    89 |   }

Typing[4401] Not immediately awaiting Awaitable-typed values requires the capability AccessStaticVariable, which is not provided by the context. [1]
-> The local (enclosing) context provides the capability ctx $async_func [2]
-> Hack provides a list of supported contexts here [3]

vendor/hhvm/hsl/src/vec/async.php:88:16
    82 |   Traversable<Tv1> $traversable,
    83 |   (function(Tv1)[_]: Awaitable<Tv2>) $async_func,
[2] 84 | )[ctx $async_func]: Awaitable<vec<Tv2>> {
    85 |   $vec = cast_clear_legacy_array_mark($traversable);
    86 |   foreach ($vec as $i => $value) {
    87 |     /* HH_FIXME[4401] need to make this safe to coeffects */
[1] 88 |     $vec[$i] = $async_func($value);
    89 |   }
    90 | 

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[3] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/vec/async.php:93:3
    91 |   /* HH_FIXME[4110] Okay to pass in Awaitable */
    92 |   /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 93 |   /* HH_FIXME[4390] Magic Function */
    94 |   await AwaitAllWaitHandle::fromVec($vec);
    95 |   foreach ($vec as $index => $value) {

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $async_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/vec/async.php:94:9
     82 |   Traversable<Tv1> $traversable,
     83 |   (function(Tv1)[_]: Awaitable<Tv2>) $async_func,
[2]  84 | )[ctx $async_func]: Awaitable<vec<Tv2>> {
     85 |   $vec = cast_clear_legacy_array_mark($traversable);
     86 |   foreach ($vec as $i => $value) {
        :
     92 |   /* HH_FIXME[4387] Hide the magic from reactivity */
     93 |   /* HH_FIXME[4390] Magic Function */
[1]  94 |   await AwaitAllWaitHandle::fromVec($vec);
     95 |   foreach ($vec as $index => $value) {
     96 |     /* HH_FIXME[4110] Reuse the existing vec to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/classes.hhi:165:26
    163 |     \ConstMap<arraykey, Awaitable<mixed>> $deps
    164 |   ): Awaitable<void>;
[3] 165 |   public static function fromVec(
    166 |     vec<Awaitable<mixed>> $deps
    167 |   ): Awaitable<void>;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
     26 | *   i.e., automatically present with the subtyped capability
     27 | */
[4]  28 | namespace HH\Contexts {
     29 | 
     30 |   /**

Typing[4390] You cannot use HH_FIXME or HH_IGNORE_ERROR comments to suppress error 4390 [1]

vendor/hhvm/hsl/src/vec/async.php:98:5
    96 |     /* HH_FIXME[4110] Reuse the existing vec to reduce peak memory. */
    97 |     /* HH_FIXME[4387] Hide the magic from reactivity */
[1] 98 |     /* HH_FIXME[4390] Magic Function */
    99 |     $vec[$index] = \HH\Asio\result($value);
   100 |   }

Typing[4390] This call is not allowed because its coeffects are incompatible with the context [1]
-> From this declaration, the context of this function body provides the capability ctx $async_func [2]
-> But the function being called requires the default capability set {AccessStaticVariable, Output, WriteProperty} [3]
-> Hack provides a list of supported contexts here [4]

vendor/hhvm/hsl/src/vec/async.php:99:20
    82 |   Traversable<Tv1> $traversable,
    83 |   (function(Tv1)[_]: Awaitable<Tv2>) $async_func,
[2] 84 | )[ctx $async_func]: Awaitable<vec<Tv2>> {
    85 |   $vec = cast_clear_legacy_array_mark($traversable);
    86 |   foreach ($vec as $i => $value) {
       :
    97 |     /* HH_FIXME[4387] Hide the magic from reactivity */
    98 |     /* HH_FIXME[4390] Magic Function */
[1] 99 |     $vec[$index] = \HH\Asio\result($value);
   100 |   }
   101 |   /* HH_FIXME[4110] Reuse the existing vec to reduce peak memory. */

/tmp/hh_server/hhi_3b2be946/stdlib/builtins_asio.hhi:17:12
    15 | namespace HH\Asio {
    16 |   function join<T>(Awaitable<T> $awaitable): T;
[3] 17 |   function result<T>(Awaitable<T> $awaitable): T;
    18 |   function name(Awaitable<mixed> $awaitable): string;
    19 |   function has_finished(Awaitable<mixed> $awaitable): bool;

/tmp/hh_server/hhi_3b2be946/coeffect/contexts.hhi:28:1
    26 | *   i.e., automatically present with the subtyped capability
    27 | */
[4] 28 | namespace HH\Contexts {
    29 | 
    30 |   /**

Typing[4128] The function HH\Lib\File\open_read_only_nd is deprecated: Use open_read_only() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:11:14
     9 | 
    10 |     try {
[1] 11 |       return File\open_read_only_nd($this->path->toString());
    12 |     } catch (\Exception $e) {
    13 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:46:10
    44 | 
    45 | <<__Deprecated("Use open_read_only() instead")>>
[2] 46 | function open_read_only_nd(string $path): CloseableReadHandle {
    47 |   return open_read_only($path);
    48 | }

Typing[4128] The function HH\Lib\File\open_write_only_nd is deprecated: Use open_write_only() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:55:14
    53 | 
    54 |     try {
[1] 55 |       return File\open_write_only_nd($this->path->toString(), $mode);
    56 |     } catch (\Exception $e) {
    57 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:51:10
    49 | 
    50 | <<__Deprecated("Use open_write_only() instead")>>
[2] 51 | function open_write_only_nd(
    52 |   string $path,
    53 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,

Typing[4128] The function HH\Lib\File\open_read_write_nd is deprecated: Use open_read_write() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:104:14
    102 | 
    103 |     try {
[1] 104 |       return File\open_read_write_nd($this->path()->toString(), $mode);
    105 |     } catch (\Exception $e) {
    106 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:60:10
     58 | 
     59 | <<__ReturnDisposable, __Deprecated("Use open_read_write() instead")>>
[2]  60 | function open_read_write_nd(
     61 |   string $path,
     62 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,

Typing[4187] Disposable objects may only be created in a using statement or return from function marked <<__ReturnDisposable>> [1]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:104:14
    102 | 
    103 |     try {
[1] 104 |       return File\open_read_write_nd($this->path()->toString(), $mode);
    105 |     } catch (\Exception $e) {
    106 |       throw new Exception\RuntimeException(

Typing[4053] No instance method writeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:310:26
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    308 |       try {
    309 |         using ($_lock = $handle->tryLockx(File\LockType::EXCLUSIVE)) {
[1] 310 |           await $handle->writeAsync($data);
    311 |         }
    312 |       } catch (File\AlreadyLockedException $e) {

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
     57 |    * do not want this to happen.
     58 |    */
[2]  59 |   public function writeAllAsync(
     60 |     string $bytes,
     61 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No instance method writeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:314:26
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    312 |       } catch (File\AlreadyLockedException $e) {
    313 |         using ($_lock = $handle->lock(File\LockType::EXCLUSIVE)) {
[1] 314 |           await $handle->writeAsync($data);
    315 |         }
    316 |       } finally {

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
     57 |    * do not want this to happen.
     58 |    */
[2]  59 |   public function writeAllAsync(
     60 |     string $bytes,
     61 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No instance method closeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean close instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:317:24
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    315 |         }
    316 |       } finally {
[1] 317 |         await $handle->closeAsync();
    318 |       }
    319 |     } catch (\Exception $e) {

vendor/hhvm/hsl-experimental/src/io/CloseableHandle.php:21:19
     19 | interface CloseableHandle extends Handle {
     20 |   /** Close the handle */
[2]  21 |   public function close(): void;
     22 | 
     23 |   /** Close the handle when the returned disposable is disposed.

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No instance method readAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:339:33
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    337 |       try {
    338 |         using ($_lock = $handle->tryLockx(File\LockType::SHARED)) {
[1] 339 |           return await $handle->readAsync($length);
    340 |         }
    341 |       } catch (File\AlreadyLockedException $e) {

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
     68 |    * unnecessarily hitting the request memory limit.
     69 |    */
[2]  70 |   public function readAllAsync(
     71 |     ?int $max_bytes = null,
     72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No instance method readAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:343:33
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    341 |       } catch (File\AlreadyLockedException $e) {
    342 |         using ($_lock = $handle->lock(File\LockType::SHARED)) {
[1] 343 |           return await $handle->readAsync($length);
    344 |         }
    345 |       } finally {

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
     68 |    * unnecessarily hitting the request memory limit.
     69 |    */
[2]  70 |   public function readAllAsync(
     71 |     ?int $max_bytes = null,
     72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No instance method closeAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean close instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:346:24
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    344 |         }
    345 |       } finally {
[1] 346 |         await $handle->closeAsync();
    347 |       }
    348 |     } catch (\Exception $e) {

vendor/hhvm/hsl-experimental/src/io/CloseableHandle.php:21:19
     19 | interface CloseableHandle extends Handle {
     20 |   /** Close the handle */
[2]  21 |   public function close(): void;
     22 | 
     23 |   /** Close the handle when the returned disposable is disposed.

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No instance method seekAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean seek instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:16:20
     7 |  */
     8 | async function copy(
[3]  9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
       :
    14 | ): Awaitable<bool> {
    15 |   if ($iteration === 0) {
[1] 16 |     await $source->seekAsync(0);
    17 |   }
    18 | 

vendor/hhvm/hsl-experimental/src/io/SeekableHandle.php:21:19
    19 |    * handle is always offset 0.
    20 |    */
[2] 21 |   public function seek(int $offset): void;
    22 | 
    23 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No instance method readAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:20:29
     7 |  */
     8 | async function copy(
[3]  9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
       :
    18 | 
    19 |   $iteration++;
[1] 20 |   $content = await $source->readAsync($max_bytes, $timeout_ns);
    21 |   if ('' !== $content) {
    22 |     await $target->writeAsync($content, $timeout_ns);

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No instance method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:22:20
     8 | async function copy(
     9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
[3] 10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
    12 |   ?int $timeout_ns = null,
       :
    20 |   $content = await $source->readAsync($max_bytes, $timeout_ns);
    21 |   if ('' !== $content) {
[1] 22 |     await $target->writeAsync($content, $timeout_ns);
    23 |     await copy($source, $target, $max_bytes, $timeout_ns, $iteration);
    24 |   }

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

Typing[4053] No instance method readAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:37:32
    28 | 
    29 | async function copy_range(
[3] 30 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    31 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    32 |   int $length,
       :
    35 | ): Awaitable<int> {
    36 |   if ($remaining >= $length) {
[1] 37 |     $contents = await $source->readAsync($length, $timeout_ns);
    38 |     if ('' !== $contents) {
    39 |       $remaining -= Str\length($contents);

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
    68 |    * unnecessarily hitting the request memory limit.
    69 |    */
[2] 70 |   public function readAllAsync(
    71 |     ?int $max_bytes = null,
    72 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No instance method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:40:22
    29 | async function copy_range(
    30 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
[3] 31 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    32 |   int $length,
    33 |   int $remaining,
       :
    38 |     if ('' !== $contents) {
    39 |       $remaining -= Str\length($contents);
[1] 40 |       await $target->writeAsync($contents);
    41 |       await copy_range($source, $target, $length, $remaining, $timeout_ns);
    42 |     }

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

Typing[4053] No instance method seekAsync in HH\Lib\IO\SeekableReadWriteHandle [1]
-> Did you mean seek instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadWriteHandle [3]
->   via this generic T [4]
-> Declaration of HH\Lib\IO\SeekableReadWriteHandle is here [5]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:20:18
     18 | 
     19 |   $remaining = $range['last'] - $range['first'] + 1;
[1]  20 |   await $source->seekAsync($range['first']);
     21 |   $remaining = await copy_range($source, $target, $maxBufferLength, $remaining);
     22 |   if ($remaining > 0) {

vendor/hhvm/hsl-experimental/src/io/SeekableHandle.php:21:19
     19 |    * handle is always offset 0.
     20 |    */
[2]  21 |   public function seek(int $offset): void;
     22 | 
     23 |   /**

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IResponse.hack:21:38
     19 |  * message and return an instance that contains the changed state.
     20 |  */
[3]  21 | interface IResponse extends IMessage<IO\SeekableReadWriteHandle> {
     22 |   /**
     23 |    * Gets the response status code.

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IMessage.hack:142:30
    140 |    * Gets the body of the message.
    141 |    */
[4] 142 |   public function getBody(): T;
    143 | 
    144 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:83:13
     81 |   interface CloseableReadWriteHandle
     82 |     extends ReadWriteHandle, CloseableWriteHandle, CloseableReadHandle {}
[5]  83 |   interface SeekableReadWriteHandle
     84 |     extends ReadWriteHandle, SeekableWriteHandle, SeekableReadHandle {}
     85 |   interface CloseableSeekableReadWriteHandle

Typing[4053] No instance method readAsync in HH\Lib\IO\SeekableReadWriteHandle [1]
-> Did you mean readAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadWriteHandle [3]
->   via this generic T [4]
-> Declaration of HH\Lib\IO\SeekableReadWriteHandle is here [5]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:23:32
     21 |   $remaining = await copy_range($source, $target, $maxBufferLength, $remaining);
     22 |   if ($remaining > 0) {
[1]  23 |     $contents = await $source->readAsync($remaining);
     24 |     if ('' !== $contents) {
     25 |       await $target->writeAsync($contents);

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:70:19
     68 |    * unnecessarily hitting the request memory limit.
     69 |    */
[2]  70 |   public function readAllAsync(
     71 |     ?int $max_bytes = null,
     72 |     ?int $timeout_ns = null,

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IResponse.hack:21:38
     19 |  * message and return an instance that contains the changed state.
     20 |  */
[3]  21 | interface IResponse extends IMessage<IO\SeekableReadWriteHandle> {
     22 |   /**
     23 |    * Gets the response status code.

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IMessage.hack:142:30
    140 |    * Gets the body of the message.
    141 |    */
[4] 142 |   public function getBody(): T;
    143 | 
    144 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:83:13
     81 |   interface CloseableReadWriteHandle
     82 |     extends ReadWriteHandle, CloseableWriteHandle, CloseableReadHandle {}
[5]  83 |   interface SeekableReadWriteHandle
     84 |     extends ReadWriteHandle, SeekableWriteHandle, SeekableReadHandle {}
     85 |   interface CloseableSeekableReadWriteHandle

Typing[4053] No instance method writeAsync in HH\Lib\IO\WriteHandle [1]
-> Did you mean writeAllAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\WriteHandle [3]
-> Declaration of HH\Lib\IO\WriteHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:25:22
     6 | async function stream(
     7 |   Message\IResponse $response,
[3]  8 |   IO\WriteHandle $target,
     9 |   int $maxBufferLength,
    10 | ): Awaitable<bool> {
       :
    23 |     $contents = await $source->readAsync($remaining);
    24 |     if ('' !== $contents) {
[1] 25 |       await $target->writeAsync($contents);
    26 |     }
    27 |   }

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:59:19
    19 |  * `rawWriteBlocking()` will immediately try to write to the handle.
    20 |  */
[4] 21 | interface WriteHandle extends Handle {
    22 |   /** An immediate unordered write.
    23 |    *
       :
    57 |    * do not want this to happen.
    58 |    */
[2] 59 |   public function writeAllAsync(
    60 |     string $bytes,
    61 |     ?int $timeout_ns = null,

62 errors found.
