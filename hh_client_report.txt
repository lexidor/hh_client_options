Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.hh:2:1
    1 | <?hh // partial
[1] 2 | require_once(__DIR__.'/autoload.hack');
    3 | Facebook\AutoloadMap\initialize();

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.hh:3:1
    1 | <?hh // partial
    2 | require_once(__DIR__.'/autoload.hack');
[1] 3 | Facebook\AutoloadMap\initialize();

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.php:2:1
    1 | <?hh // partial
[1] 2 | require_once(__DIR__.'/autoload.hack');
    3 | Facebook\AutoloadMap\initialize();

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/hh_autoload.php:3:1
    1 | <?hh // partial
    2 | require_once(__DIR__.'/autoload.hack');
[1] 3 | Facebook\AutoloadMap\initialize();

Typing[4138] The assigned type of this type constant is inconsistent with its parent [1]
-> This shape type allows unknown fields, and so it may contain fields other than those explicitly declared in its declaration. [2]
-> It is incompatible with a shape that does not allow unknown fields. [3]

vendor/hhvm/hhast/src/Linters/ConsistentLineEndingsLinter.hack:18:14
      16 |   extends AutoFixingLineLinter<LineLintError> {
      17 |   // Could become configurable later.
[1,3] 18 |   const type TConfig = shape('line ending' => LineEnding);
      19 | 
      20 |   private function getLineEnding(): LineEnding {

vendor/hhvm/hhast/src/Linters/BaseLinter.hack:19:38
      17 | abstract class BaseLinter {
      18 |   <<__Reifiable>>
[2]   19 |   const type TConfig as shape(...) = shape(...);
      20 | 
      21 |   abstract public function getLintErrorsAsync(): Awaitable<vec<LintError>>;

Parsing[1002] XHP children declarations are no longer supported. [1]

vendor/hhvm/hhast/src/__Private/codegen/data/XHPChildrenSyntaxExample.hack:12:12
    10 | 
    11 | class :xhpchildren1 {
[1] 12 |   children (pcdata);
    13 | }
    14 | 

Naming[2049] Unbound name: Facebook\AutoloadMap\TestFixtures\MyExampleTest (an object type) [1]

vendor/hhvm/hhvm-autoload/testdata/fixtures/hh-only/test-dev.php:37:19
    35 |   );
    36 |   invariant(
[1] 37 |     \class_exists(MyExampleTest::class),
    38 |     "Should be able to load class from dev root in prod mode",
    39 |   );

Naming[2049] Unbound name: Facebook\AutoloadMap\TestFixtures\MyExampleTest (an object type) [1]

vendor/hhvm/hhvm-autoload/testdata/fixtures/hh-only/test-prod.php:39:20
    37 |   );
    38 |   invariant(
[1] 39 |     !\class_exists(MyExampleTest::class),
    40 |     "Should *not* be able to load class from dev root in prod mode",
    41 |   );

Parsing[1002] Toplevel statements are not allowed. Use __EntryPoint attribute instead [1]

vendor/nuxed/console/example/app.hack:5:1
    3 | use namespace Nuxed\Console;
    4 | 
[1] 5 | require __DIR__.'/../vendor/hh_autoload.hh';
    6 | 
    7 | <<__EntryPoint>>

Parsing[1002] The goto operator is not allowed in Hack files [1]

vendor/nuxed/console/src/Nuxed/Console/Application.hack:312:11
    310 |         $exitCode = $event->getExitCode();
    311 |         if ($exitCode === Command\ExitCode::Success) {
[1] 312 |           goto terminate;
    313 |         }
    314 |       }

Parsing[1002] Labels are used only for goto, which is not allowed in Hack files [1]

vendor/nuxed/console/src/Nuxed/Console/Application.hack:320:5
    318 |     }
    319 | 
[1] 320 |     terminate:
    321 |     return await $this->terminate($input, $output, $command, 0);
    322 |   }

Naming[2049] Unbound name: Nuxed\Console\ErrorHandler\array [1]

vendor/nuxed/console/src/Nuxed/Console/ErrorHandle/ErrorHandler.hack:89:10
    87 |         /* HH_IGNORE_ERROR[4110] */
    88 |         $exception->getTrace(),
[1] 89 |         (array<string, mixed> $frame): dict<string, string> ==> {
    90 |           unset($frame['args']);
    91 |           /* HH_IGNORE_ERROR[4110] */

Typing[4110] Invalid argument [1]
-> Expected Nuxed\Console\ErrorHandler\array<string, mixed> [2]
-> But got darray<string, mixed> [3]
->   via this generic Tv1 [4]

vendor/nuxed/console/src/Nuxed/Console/ErrorHandle/ErrorHandler.hack:89:9
       84 | 
       85 |     $frames = Vec\filter<dict<string, string>>(
[3]    86 |       Vec\map<darray<string, mixed>, dict<string, string>>(
       87 |         /* HH_IGNORE_ERROR[4110] */
       88 |         $exception->getTrace(),
[1,2]  89 |         (array<string, mixed> $frame): dict<string, string> ==> {
[1]    90 |           unset($frame['args']);
[1]    91 |           /* HH_IGNORE_ERROR[4110] */
[1]    92 |           return dict<string, string>($frame);
[1]    93 |         },
       94 |       ),
       95 |       (dict<string, string> $frame): bool ==>

vendor/hhvm/hsl/src/vec/transform.php:105:13
      103 |   Traversable<Tv1> $traversable,
      104 |   <<__AtMostRxAsFunc>>
[4]   105 |   (function(Tv1): Tv2) $value_func,
      106 | ): vec<Tv2> {
      107 |   $result = vec[];

Typing[4005] This is not an object of type KeyedContainer, this is an object of type Nuxed\Console\ErrorHandler\array<string, mixed> [1]
-> Definition is here [2]

vendor/nuxed/console/src/Nuxed/Console/ErrorHandle/ErrorHandler.hack:90:17
    87 |         /* HH_IGNORE_ERROR[4110] */
    88 |         $exception->getTrace(),
[2] 89 |         (array<string, mixed> $frame): dict<string, string> ==> {
[1] 90 |           unset($frame['args']);
    91 |           /* HH_IGNORE_ERROR[4110] */
    92 |           return dict<string, string>($frame);

Typing[4341] The method getCode has the wrong type [1]
-> This function is pure. [2]
-> This function is reactive. [1]

vendor/nuxed/console/src/Nuxed/Console/Exception/CommandNotFoundException.hack:13:19
    11 | 
    12 |   <<__Rx, __MaybeMutable>>
[1] 13 |   public function getCode(): int {
    14 |     return Command\ExitCode::CommandNotFound;
    15 |   }

/tmp/hh_server/hhi_2f627d0/exceptions.hhi:99:19
    97 |   public final function setPrevious(Exception $previous): void;
    98 |   <<__Pure, __MaybeMutable>>
[2] 99 |   public function getCode(): int;
   100 |   <<__Pure, __MaybeMutable>>
   101 |   final public function getFile(): string;

Typing[4128] The function HH\Lib\File\open_read_only_nd is deprecated: Use open_read_only() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:11:14
     9 | 
    10 |     try {
[1] 11 |       return File\open_read_only_nd($this->path->toString());
    12 |     } catch (\Exception $e) {
    13 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:46:10
    44 | 
    45 | <<__Deprecated("Use open_read_only() instead")>>
[2] 46 | function open_read_only_nd(string $path): CloseableReadHandle {
    47 |   return open_read_only($path);
    48 | }

Typing[4128] The function HH\Lib\File\open_write_only_nd is deprecated: Use open_write_only() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:55:14
    53 | 
    54 |     try {
[1] 55 |       return File\open_write_only_nd($this->path->toString(), $mode);
    56 |     } catch (\Exception $e) {
    57 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:51:10
    49 | 
    50 | <<__Deprecated("Use open_write_only() instead")>>
[2] 51 | function open_write_only_nd(
    52 |   string $path,
    53 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,

Typing[4128] The function HH\Lib\File\open_read_write_nd is deprecated: Use open_read_write() instead [1]
-> Definition is here [2]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:104:14
    102 | 
    103 |     try {
[1] 104 |       return File\open_read_write_nd($this->path()->toString(), $mode);
    105 |     } catch (\Exception $e) {
    106 |       throw new Exception\RuntimeException(

vendor/hhvm/hsl-experimental/src/file/open.php:60:10
     58 | 
     59 | <<__ReturnDisposable, __Deprecated("Use open_read_write() instead")>>
[2]  60 | function open_read_write_nd(
     61 |   string $path,
     62 |   WriteMode $mode = WriteMode::OPEN_OR_CREATE,

Typing[4187] Disposable objects may only be created in a using statement or return from function marked <<__ReturnDisposable>> [1]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:104:14
    102 | 
    103 |     try {
[1] 104 |       return File\open_read_write_nd($this->path()->toString(), $mode);
    105 |     } catch (\Exception $e) {
    106 |       throw new Exception\RuntimeException(

Typing[4053] No method closeAsync in HH\Lib\File\CloseableWriteHandle [1]
-> Did you mean writeAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableWriteHandle [3]
-> Declaration of HH\Lib\File\CloseableWriteHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:317:24
     24 |   public function getWriteHandle(
     25 |     File\WriteMode $mode = File\WriteMode::OPEN_OR_CREATE,
[3]  26 |   ): File\CloseableWriteHandle {
     27 |     if ($mode === File\WriteMode::MUST_CREATE && $this->exists()) {
     28 |       throw new Exception\ExistingNodeException(Str\format(
        :
    315 |         }
    316 |       } finally {
[1] 317 |         await $handle->closeAsync();
    318 |       }
    319 |     } catch (\Exception $e) {

vendor/hhvm/hsl-experimental/src/io/WriteHandle.php:44:19
     42 |    *   input string.
     43 |    */
[2]  44 |   public function writeAsync(
     45 |     string $bytes,
     46 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:22:11
     20 | }
     21 | 
[4]  22 | interface CloseableWriteHandle
     23 |   extends
     24 |     IO\CloseableSeekableWriteHandle,

Typing[4053] No method closeAsync in HH\Lib\File\CloseableReadHandle [1]
-> Did you mean close instead? [2]
-> This is why I think it is an object of type HH\Lib\File\CloseableReadHandle [3]
-> Declaration of HH\Lib\File\CloseableReadHandle is here [4]

vendor/nuxed/filesystem/src/Nuxed/Filesystem/File.hack:346:24
      4 | 
      5 | final class File extends Node {
[3]   6 |   public function getReadHandle(): File\CloseableReadHandle {
      7 |     $this->isAvailable();
      8 |     $this->isReadable();
        :
    344 |         }
    345 |       } finally {
[1] 346 |         await $handle->closeAsync();
    347 |       }
    348 |     } catch (\Exception $e) {

vendor/hhvm/hsl-experimental/src/io/CloseableHandle.php:21:19
     19 | interface CloseableHandle extends Handle {
     20 |   /** Close the handle */
[2]  21 |   public function close(): void;
     22 | 
     23 |   /** Close the handle when the returned disposable is disposed.

vendor/hhvm/hsl-experimental/src/file/CloseableHandle.php:18:11
     16 | }
     17 | 
[4]  18 | interface CloseableReadHandle
     19 |   extends IO\CloseableSeekableReadHandle, CloseableHandle, ReadHandle {
     20 | }

Typing[4053] No method seekAsync in HH\Lib\IO\SeekableReadHandle [1]
-> Did you mean readAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadHandle [3]
-> Declaration of HH\Lib\IO\SeekableReadHandle is here [4]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/copy.hack:16:20
     7 |  */
     8 | async function copy(
[3]  9 |   <<__AcceptDisposable>> IO\SeekableReadHandle $source,
    10 |   <<__AcceptDisposable>> IO\WriteHandle $target,
    11 |   ?int $max_bytes = null,
       :
    14 | ): Awaitable<bool> {
    15 |   if ($iteration === 0) {
[1] 16 |     await $source->seekAsync(0);
    17 |   }
    18 | 

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:56:19
    54 |    *   - the empty string if the end of file is reached.
    55 |    */
[2] 56 |   public function readAsync(
    57 |     ?int $max_bytes = null,
    58 |     ?int $timeout_ns = null,

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:70:13
    68 |   interface CloseableSeekableHandle extends SeekableHandle, CloseableHandle {}
    69 |   interface CloseableReadHandle extends ReadHandle, CloseableHandle {}
[4] 70 |   interface SeekableReadHandle extends ReadHandle, SeekableHandle {}
    71 |   interface CloseableSeekableReadHandle
    72 |     extends SeekableReadHandle, CloseableReadHandle, CloseableSeekableHandle {}

Typing[4053] No method seekAsync in HH\Lib\IO\SeekableReadWriteHandle [1]
-> Did you mean readAsync instead? [2]
-> This is why I think it is an object of type HH\Lib\IO\SeekableReadWriteHandle [3]
->   via this generic T [4]
-> Declaration of HH\Lib\IO\SeekableReadWriteHandle is here [5]

vendor/nuxed/http-emitter/src/Nuxed/Http/Emitter/_Private/stream.hack:20:18
     18 | 
     19 |   $remaining = $range['last'] - $range['first'] + 1;
[1]  20 |   await $source->seekAsync($range['first']);
     21 |   $remaining = await copy_range($source, $target, $maxBufferLength, $remaining);
     22 |   if ($remaining > 0) {

vendor/hhvm/hsl-experimental/src/io/ReadHandle.php:56:19
     54 |    *   - the empty string if the end of file is reached.
     55 |    */
[2]  56 |   public function readAsync(
     57 |     ?int $max_bytes = null,
     58 |     ?int $timeout_ns = null,

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IResponse.hack:21:38
     19 |  * message and return an instance that contains the changed state.
     20 |  */
[3]  21 | interface IResponse extends IMessage<IO\SeekableReadWriteHandle> {
     22 |   /**
     23 |    * Gets the response status code.

vendor/nuxed/contract/src/Nuxed/Contract/Http/Message/IMessage.hack:142:30
    140 |    * Gets the body of the message.
    141 |    */
[4] 142 |   public function getBody(): T;
    143 | 
    144 |   /**

vendor/hhvm/hsl-experimental/src/io/intersection_interfaces.php:83:13
     81 |   interface CloseableReadWriteHandle
     82 |     extends ReadWriteHandle, CloseableWriteHandle, CloseableReadHandle {}
[5]  83 |   interface SeekableReadWriteHandle
     84 |     extends ReadWriteHandle, SeekableWriteHandle, SeekableReadHandle {}
     85 |   interface CloseableSeekableReadWriteHandle

23 errors found.
